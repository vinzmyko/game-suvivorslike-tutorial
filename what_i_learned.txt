2:
- Can ctrl + drag so increase values in increments of 1 pixel.
3:
- Nodes furthers down the tree's ready() function is called first. ie. Bottom to top ready functions are called first
4:
- Node draw order is the opposite meaning nodes higher up are drawn first. ie. Nodes near the bottom are above everything
5:
- Ctrl + Shift + O = Quick open scene
7:
Ctrl + Shift + A = Quick add scene to current scene
11:
-used functions are an arugument to a function.
	Array's filter(method) function which goes through each element in the array and does an operation on it which in set
	inside the function parameters. If it returns true then it doesn't get filtered out.
	eg. enemies = enemies.filter(func(enemy: Node2D):
		return enemy.global_position.distance_squared_to(player.global_position) < pow(MAX_RANGE, 2)
	)
	NOTE YOU GOT TO WE HAVE TO REASSIGN ENEMIES SO IT ACTUALLY UPDATES AND WE CAN USE IT
	Goes through each enemy in the enemies array and checks if it is within the MAX_RANGE, if it's not in the MAX_RANGE
	then it get filtered out. After the filter function gets run, the enemies array will only have enemies that are
	within the range.
	
	Array's sort_custom(func) function. This sorts the array using a function. The function should have 2 arguments
	which are the elements in the array. The function must return either true or false. If it returns true then
	element b will be sorted after element a.
	eg. 	enemies.sort_custom(func(a:Node2D, b:Node2D):
		var a_distance = a.global_position.distance_squared_to(player.global_position)
		var b_distance = b.global_position.distance_squared_to(player.global_position)
		return a_distance < b_distance
	)
	This function basically sorts the enemies from closest to farthest with index 0 being the closest. Calculates the
	distance from the player and element a and does the same with with element b. Then it checks to see if element a
	is less than element b if it's true then element b will go after element a meaning that the furthest element will
	go up in the index.
12:
- Project settings -> Rendering -> Snap 2D transforms into pixel
This one is good as all the pixel positions are a float value like Vector2(5.7, -10.3) but this setting makes it only
use ints so it will make the game look smoother. If you are using lerp for acceleration turn it off as lerping goes
through floating point values but they snap to the nearest integer which makes it jittery
15:
- GDScript: if you want a quick way to rename a word you can highlight it and the press Ctrl + D and it will highlight
another one, you can spam press this to highlight all the same names and then you can change them all at once!
- Cool way to format strings: You can use change how much 0's show up in the formatted string.
eg. return str(minutes) + ":" + ("%02d" % floor(remaining_seconds)) this on makes the remaining seconds have a 0
at the start so it won't show up at 8 but 08.
16:
- Collision Mask is the one that does the code so when you are choosing which one to highlight mask or layer, which ever
object that you are going to be writing the logic to put it into the mask layer as this is the one where you connect
the signal to and write the code to.
18:
- If you are trying to queue_free() somethiing that is handling collisions it will give you an error, the way to fix it
goes as follows, you need to deffer the call, 
eg. Callable(check_death).call_deferred()
This only calls the function after it does all the necessary calculations
19:
- How this guy abstracts components is he has a scene for the actual ability and then he has a hurtbox component on all
abilities. He then has a controller object that manages the spawning of the ability on where.
- Before he put all the functionality of taking damage from the basic_enemy main node to the HurtboxComponent which
handles all the damage done. Via on_area_entered signal. The HealthComponent is the one that deals with the damage to
the object.
-In the sword ability it only contains a refference to the HitboxComponent which does all the logic which is actually
nothing as of right now as all it needs to do it spawn the HitboxArea2D on the enemy and that does everything as the
sword controller handles the damage
-On margin containers remember to go to Mouse -> Filter -> Ignore. REMEMBER ALL CONTROL NODES HAS A MOUSE FILTER SETTING
22:
-He has logic for certain things in each node and he gets a refference to that node via @export var node: Node and then
the calls the functions from that node on the manager/handler script
- When you want to pause the game use get_tree().pause = true, but you need to go to the setting
Node -> Process -> Mode -> Always
23:
-.connect(function_name.bind()) able to bind parameters when the callable doesn't have any
-How the level up workflow goes:
	Collect vials emits a signal -> ExperienceManager listens to it and handles current exp calcs to level up
	-> When you have enough exp to level up -> emits level up signal -> UpgradeManager listens to it
	-> Picks from random ability in the ability pool -> instance upgrade screen pop up -> calls upgrade_scene's method
	which takes an array of upgrades and instances new cards on the screen -> also connects to an input selected signal
	on the upgrade_screen -> which applies upgrade on click
- Use of GameEvents singleton (global signal bus) is to push variables to the very top of the scenetree and then push them
back down to other handlers. eg.
	func emit_ability_upgrades_added(upgrade: AbilityUpgrade, current_upgrades: Dictionary):
		ability_upgrades_added.emit(upgrade, current_upgrades)
we can emit this when a new upgrade is added and then connect to this on the script that we want to handle it, remember
defensive coding and use if upgrade != "sword_rate": [resource id name]
							return
25:
- Use of Node2D -> CanvasLayer -> Ordering ->Y Sort Enabled
When you want to spawn objects on a certain node which will hold them ie such as Foreground nodes that you want to appear
at the front, you can use groups and put _layer at the end so you know it's only got 1 node attached to it.
What I would normally do is $../../../Foreground.add_child. This is bad because if the scene tree changes you are fucked
so why not use var foreground_layer = get_tree().get_first_node_in_group("foreground_layer")
foreground_layer.add_child()
